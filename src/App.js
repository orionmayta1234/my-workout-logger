import React, { useState, useEffect, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { 
    getAuth, 
    onAuthStateChanged, 
    GoogleAuthProvider, 
    signInWithPopup, 
    signOut,
} from 'firebase/auth';
import { 
    getFirestore, 
    doc, 
    setDoc, 
    getDoc, 
    addDoc, 
    collection, 
    query, 
    onSnapshot, 
    deleteDoc, 
    serverTimestamp, 
    writeBatch // Added for batch updates
} from 'firebase/firestore';
import { 
    PlusCircle, Play, Pause, StopCircle, Edit3, Trash2, Save, XCircle, CheckCircle, 
    ChevronDown, ChevronUp, Clock, Dumbbell, 
    Home, 
    Calendar, Edit, 
    LogOut, SkipForward, RotateCcw, Replace, MessageSquareWarning, AlertTriangle, History, GripVertical // Added GripVertical
} from 'lucide-react';

// --- Firebase Configuration ---
const firebaseConfig = {
  apiKey: "AIzaSyDZP5VN_0wlESJ241x5nDPL9zEnMf41Fz4",
  authDomain: "workout-logger-336c4.firebaseapp.com",
  projectId: "workout-logger-336c4",
  storageBucket: "workout-logger-336c4.appspot.com", 
  messagingSenderId: "262377379612",
  appId: "1:262377379612:web:42333319dd6d49ffdc0cd9"
};
const appId = firebaseConfig.appId;

// --- Helper Functions ---
const generateId = () => Math.random().toString(36).substr(2, 9);

const formatRepRange = (min, max) => { /* ... as before ... */ const minReps = parseInt(min, 10); const maxReps = parseInt(max, 10); if (!isNaN(minReps) && !isNaN(maxReps)) { return `${minReps}-${maxReps} reps`; } else if (!isNaN(minReps)) { return `${minReps}+ reps`; } else if (!isNaN(maxReps)) { return `up to ${maxReps} reps`; } return 'reps'; };
const formatPreviousPerformanceString = (loggedSets) => { /* ... as before ... */ if (!loggedSets || loggedSets.length === 0) return null; const completedSets = loggedSets.filter(s => s.completed && String(s.reps).trim() && String(s.weight).trim()); if (completedSets.length === 0) return null; const numSets = completedSets.length; const repsList = completedSets.map(s => String(s.reps).trim()); const weightsList = completedSets.map(s => String(s.weight).trim()); const uniqueReps = [...new Set(repsList)]; const uniqueWeights = [...new Set(weightsList)]; let repsDisplay; if (uniqueReps.length === 1) { repsDisplay = `${uniqueReps[0]} reps`; } else if (uniqueReps.length > 1) { repsDisplay = `(${repsList.join(', ')}) reps`; } else { repsDisplay = 'N/A reps'; } let weightDisplay; if (uniqueWeights.length === 1 && uniqueWeights[0]) { weightDisplay = `@ ${uniqueWeights[0]}lbs`; } else if (uniqueWeights.length > 1) { weightDisplay = `@ (${weightsList.join(', ')}) lbs`; } else { weightDisplay = ''; } if (numSets === 0) return null; if (uniqueReps.length === 1 && (uniqueWeights.length === 1 && uniqueWeights[0])) { return `${numSets} set${numSets > 1 ? 's' : ''} of ${repsDisplay} ${weightDisplay}`; } else if (uniqueWeights.length === 1 && uniqueWeights[0]) { return `${numSets} set${numSets > 1 ? 's' : ''} of ${repsDisplay} ${weightDisplay}`; } else if (uniqueReps.length === 1) { return `${numSets} set${numSets > 1 ? 's' : ''} of ${repsDisplay} ${weightDisplay}`; } else { const individualSetStrings = completedSets.map(s => `${s.reps || 'N/A'}r @ ${s.weight || 'N/A'}lbs`); if (individualSetStrings.length > 0) { return `${numSets} set${numSets > 1 ? 's' : ''}: ${individualSetStrings.join('; ')}`; } return `${numSets} set${numSets > 1 ? 's' : ''} with varying reps/weights.`; } };

// --- MODAL COMPONENT ---
const Modal = ({ isOpen, onClose, title, children, showCancelButton = false, onConfirm, confirmText = "OK", cancelText = "Cancel" }) => { /* ... as before ... */ if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[100] p-4"><div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md"><div className="flex justify-between items-center mb-4"><h2 className="text-xl font-semibold text-pink-400">{title}</h2><button onClick={onClose} className="text-gray-400 hover:text-gray-200"><XCircle size={24} /></button></div><div className="mb-6">{children}</div><div className={`flex ${showCancelButton ? 'justify-between' : 'justify-end'} space-x-3`}>{showCancelButton && ( <button onClick={onClose} className="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg transition-colors">{cancelText}</button>)}<button onClick={onConfirm || onClose} className={`${onConfirm ? 'bg-pink-600 hover:bg-pink-700' : 'bg-blue-600 hover:bg-blue-700'} text-white font-semibold py-2 px-4 rounded-lg transition-colors`}>{confirmText}</button></div></div></div> );};
const LoginScreen = React.memo(({ onSignInWithGoogle }) => ( /* ... as before ... */ <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 p-4"><div className="bg-gray-800 p-8 md:p-12 rounded-xl shadow-2xl text-center"><Dumbbell size={64} className="text-pink-500 mx-auto mb-6" /><h1 className="text-4xl font-bold text-pink-500 mb-4">FitTrack</h1><p className="text-gray-400 mb-8 text-lg">Log your workouts and track your progress.</p><button onClick={onSignInWithGoogle} className="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-lg flex items-center justify-center w-full transition-colors duration-150"><svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.56,12.25C22.56,11.47 22.49,10.72 22.36,10H12V14.26H17.94C17.63,15.91 16.77,17.31 15.32,18.25V21.09H19.16C21.32,19.16 22.56,15.97 22.56,12.25Z"/></svg> Sign in with Google</button></div><p className="text-gray-500 text-sm mt-8">By signing in, you agree to our imaginary Terms of Service.</p></div>));

// --- SCREEN COMPONENTS ---
const HomeScreen = React.memo(({ workouts, onStartWorkout, onEditWorkoutTemplate, onDeleteWorkoutTemplate, onCreateNewWorkout, onWorkoutPlanDragStart, onWorkoutPlanDragOver, onWorkoutPlanDrop, onWorkoutPlanDragEnd }) => ( <div className="p-4 md:p-6"><h1 className="text-3xl font-bold mb-6 text-center text-pink-500">My Workouts</h1><div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">{workouts.map((workout, index) => (<div key={workout.id} id={`workout-plan-${workout.id}`} draggable="true" onDragStart={(e) => onWorkoutPlanDragStart(e, index)} onDragOver={onWorkoutPlanDragOver} onDrop={(e) => onWorkoutPlanDrop(e, index)} onDragEnd={onWorkoutPlanDragEnd} className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-grab active:cursor-grabbing relative"><div className="absolute top-2 right-2 text-gray-500 opacity-50 hover:opacity-100"><GripVertical size={20} /></div><h2 className="text-xl font-semibold mb-2 text-pink-400">{workout.name}</h2><ul className="text-sm text-gray-400 mb-3 list-disc list-inside">{(workout.exercises || []).slice(0,3).map(ex => (<li key={ex.id}>{ex.name} ({ex.targetSets}x{formatRepRange(ex.targetRepsMin, ex.targetRepsMax)} {ex.targetWeight ? `@ ${ex.targetWeight}lbs` : ''})</li>))}{(workout.exercises || []).length > 3 && <li>...and more</li>}</ul><div className="flex justify-between items-center mt-auto pt-2"><button onClick={() => onStartWorkout(workout)} className="bg-pink-600 hover:bg-pink-700 text-white font-semibold py-2 px-4 rounded-lg flex items-center transition-colors"><Play size={18} className="mr-2" /> Start</button><div><button onClick={() => onEditWorkoutTemplate(workout)} className="text-blue-400 hover:text-blue-300 mr-2 p-1"><Edit3 size={18}/></button><button onClick={() => onDeleteWorkoutTemplate(workout.id)} className="text-red-400 hover:text-red-300 p-1"><Trash2 size={18}/></button></div></div></div>))}{workouts.length === 0 && <p className="text-gray-400 col-span-full text-center py-8">No workout plans yet. Create one to get started!</p>}</div><button onClick={onCreateNewWorkout} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg transition-colors"><PlusCircle size={22} className="mr-2" /> Create New Workout Plan</button></div>));
const CreateEditWorkoutScreen = React.memo(({ editingWorkout, onWorkoutNameChange, onExerciseChange, onAddExerciseToTemplate, onRemoveExerciseFromTemplate, onSaveWorkoutTemplate, onCancel, onExerciseDragStart, onExerciseDragOver, onExerciseDrop, onExerciseDragEnd }) => { if (!editingWorkout) return null; return ( <div className="p-4 md:p-6"><h1 className="text-3xl font-bold mb-6 text-center text-pink-500">{editingWorkout.id ? 'Edit Workout Plan' : 'Create New Workout Plan'}</h1><div className="bg-gray-800 p-6 rounded-lg shadow-xl"><div className="mb-6"><label htmlFor="workoutName" className="block text-sm font-medium text-gray-300 mb-1">Workout Name</label><input type="text" id="workoutName" value={editingWorkout.name} onChange={(e) => onWorkoutNameChange(e.target.value)} className="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-3 focus:ring-pink-500 focus:border-pink-500" placeholder="e.g., Pull Day, Leg Blast"/></div><h2 className="text-xl font-semibold mb-3 text-pink-400">Exercises</h2>{editingWorkout.exercises.map((exercise, index) => (<div key={exercise.id} id={`exercise-item-${exercise.id}`} draggable="true" onDragStart={(e) => onExerciseDragStart(e, index)} onDragOver={onExerciseDragOver} onDrop={(e) => onExerciseDrop(e, index)} onDragEnd={onExerciseDragEnd} className="bg-gray-700 p-4 rounded-md mb-4 border border-gray-600 cursor-grab active:cursor-grabbing flex items-start space-x-3"><div className="pt-1 text-gray-500 opacity-70 hover:opacity-100"><GripVertical size={20} /></div><div className="flex-grow"><div className="flex justify-between items-center mb-2"><span className="text-lg font-medium text-gray-200">Exercise #{index + 1}</span><button onClick={() => onRemoveExerciseFromTemplate(exercise.id)} className="text-red-400 hover:text-red-300 p-1"><Trash2 size={18}/></button></div><div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4"><div><label htmlFor={`exName-${exercise.id}`} className="block text-xs text-gray-400 mb-1">Name</label><input type="text" id={`exName-${exercise.id}`} value={exercise.name} onChange={(e) => onExerciseChange(index, 'name', e.target.value)} placeholder="Exercise Name" className="w-full bg-gray-600 border-gray-500 text-white rounded p-2 text-sm"/></div><div><label htmlFor={`exSets-${exercise.id}`} className="block text-xs text-gray-400 mb-1">Target Sets</label><input type="number" id={`exSets-${exercise.id}`} value={exercise.targetSets} onChange={(e) => onExerciseChange(index, 'targetSets', e.target.value)} placeholder="Sets" className="w-full bg-gray-600 border-gray-500 text-white rounded p-2 text-sm"/></div><div className="grid grid-cols-2 gap-2"><div><label htmlFor={`exRepsMin-${exercise.id}`} className="block text-xs text-gray-400 mb-1">Min Reps</label><input type="number" id={`exRepsMin-${exercise.id}`} value={exercise.targetRepsMin || ''} onChange={(e) => onExerciseChange(index, 'targetRepsMin', e.target.value)} placeholder="Min" className="w-full bg-gray-600 border-gray-500 text-white rounded p-2 text-sm"/></div><div><label htmlFor={`exRepsMax-${exercise.id}`} className="block text-xs text-gray-400 mb-1">Max Reps</label><input type="number" id={`exRepsMax-${exercise.id}`} value={exercise.targetRepsMax || ''} onChange={(e) => onExerciseChange(index, 'targetRepsMax', e.target.value)} placeholder="Max" className="w-full bg-gray-600 border-gray-500 text-white rounded p-2 text-sm"/></div></div><div><label htmlFor={`exWeight-${exercise.id}`} className="block text-xs text-gray-400 mb-1">Target Weight (lbs)</label><input type="number" id={`exWeight-${exercise.id}`} value={exercise.targetWeight} onChange={(e) => onExerciseChange(index, 'targetWeight', e.target.value)} placeholder="Weight" className="w-full bg-gray-600 border-gray-500 text-white rounded p-2 text-sm"/></div></div></div></div>))}{editingWorkout.exercises.length === 0 && <p className="text-sm text-gray-400 text-center py-2">No exercises added yet.</p>}<button onClick={onAddExerciseToTemplate} className="w-full text-green-400 hover:text-green-300 border-2 border-green-500 hover:border-green-400 rounded-lg py-2 px-4 mb-6 flex items-center justify-center transition-colors"><PlusCircle size={20} className="mr-2"/> Add Exercise</button><div className="flex justify-end space-x-3"><button onClick={onCancel} className="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg transition-colors">Cancel</button><button onClick={onSaveWorkoutTemplate} className="bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-6 rounded-lg transition-colors flex items-center"><Save size={18} className="mr-2"/> Save Plan</button></div></div></div> );});
const ActiveWorkoutScreen = React.memo(({ activeWorkout, bodyWeight, workoutNotes, onSetBodyWeight, onSetWorkoutNotes, onSetInputChange, onAddSetToExercise, onLogSet, onUnlogSet, onFinishWorkout, onCancelWorkout, showBodyWeightInput, onHideBodyWeightInput, onToggleSkipExercise, onStartReplaceExercise, replacingExerciseIndex, onConfirmReplaceExercise, onCancelReplaceExercise, tempReplaceName, onSetTempReplaceName }) => { /* ... as before ... */ if (!activeWorkout) return <div className="p-4 text-center">No active workout. Go back to select one.</div>; return ( <div className="p-4 md:p-6"><div className="flex justify-between items-center mb-4"><button onClick={onCancelWorkout} className="text-pink-400 hover:text-pink-300 flex items-center"><XCircle size={20} className="mr-1"/> End Workout (Discard)</button><h1 className="text-3xl font-bold text-pink-500 text-center">{activeWorkout.name}</h1><div/></div>{showBodyWeightInput && (<div className="mb-6 bg-gray-800 p-4 rounded-lg"><label htmlFor="bodyWeight" className="block text-sm font-medium text-gray-300 mb-1">Current Body Weight (lbs)</label><div className="flex items-center space-x-2"><input type="number" id="bodyWeight" value={bodyWeight} onChange={(e) => onSetBodyWeight(e.target.value)} className="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-2 focus:ring-pink-500 focus:border-pink-500" placeholder="e.g., 167.2"/><button onClick={onHideBodyWeightInput} className="bg-pink-500 hover:bg-pink-600 text-white p-2 rounded-lg"><CheckCircle size={20}/></button></div></div>)}{activeWorkout.exercises.map((exercise, exIndex) => (<div key={exercise.id} className={`bg-gray-800 p-4 rounded-lg shadow-md mb-4 ${exercise.isSkipped ? 'opacity-50' : ''}`}><div className="flex justify-between items-start mb-1"><div><h2 className="text-xl font-semibold text-pink-400">{exercise.name}</h2>{exercise.previousPerformance && (<div className="text-xs text-gray-500 mt-0.5 mb-1 flex items-center"><History size={12} className="mr-1 flex-shrink-0" />Previously: {exercise.previousPerformance}</div>)}{!exercise.previousPerformance && (<div className="text-xs text-gray-500 mt-0.5 mb-1 flex items-center"><History size={12} className="mr-1 flex-shrink-0" />No previous data for this exercise in this plan.</div>)}<span className="text-sm text-gray-400 block">Target: {exercise.targetSets}x{formatRepRange(exercise.targetRepsMin, exercise.targetRepsMax)} {exercise.targetWeight ? `@ ${exercise.targetWeight}lbs` : ''}</span></div><div className="flex space-x-1 mt-1">{replacingExerciseIndex !== exIndex && !exercise.isSkipped && (<button onClick={() => onStartReplaceExercise(exIndex, exercise.name)} className="p-1 text-blue-400 hover:text-blue-300" title="Replace Exercise"><Replace size={16}/></button>)}<button onClick={() => onToggleSkipExercise(exIndex)} className={`p-1 ${exercise.isSkipped ? 'text-yellow-400 hover:text-yellow-300' : 'text-gray-400 hover:text-gray-300'}`} title={exercise.isSkipped ? "Unskip Exercise" : "Skip Exercise"}><SkipForward size={16}/></button></div></div>{replacingExerciseIndex === exIndex && (<div className="my-2 p-2 bg-gray-700 rounded"><input type="text" value={tempReplaceName} onChange={(e) => onSetTempReplaceName(e.target.value)} placeholder="New exercise name" className="w-full bg-gray-600 text-white p-2 rounded mb-2 text-sm" autoFocus/><div className="flex justify-end space-x-2"><button onClick={onCancelReplaceExercise} className="text-xs bg-gray-500 hover:bg-gray-400 px-2 py-1 rounded">Cancel</button><button onClick={() => onConfirmReplaceExercise(exIndex)} className="text-xs bg-green-600 hover:bg-green-500 px-2 py-1 rounded">Confirm</button></div></div>)}{!exercise.isSkipped && exercise.loggedSets.map((set, setIndex) => (<div key={`${exercise.id}-set-${setIndex}`} className={`flex items-center space-x-2 mb-3 p-3 rounded-md ${set.completed ? 'bg-green-800 border-green-600' : 'bg-gray-700 border-gray-600'} border`}><span className="text-gray-300 font-medium w-8 text-center">Set {setIndex + 1}</span><input type="number" placeholder="Reps" value={set.reps} onChange={(e) => onSetInputChange(exIndex, setIndex, 'reps', e.target.value)} className="bg-gray-600 text-white border border-gray-500 rounded-full w-20 h-12 text-center text-lg appearance-none focus:ring-pink-500 focus:border-pink-500"/><span className="text-gray-400">x</span><input type="number" placeholder="lbs" value={set.weight} onChange={(e) => onSetInputChange(exIndex, setIndex, 'weight', e.target.value)} className="bg-gray-600 text-white border border-gray-500 rounded-full w-20 h-12 text-center text-lg appearance-none focus:ring-pink-500 focus:border-pink-500"/>{!set.completed && (set.reps || set.weight) && (<button onClick={() => onLogSet(exIndex, setIndex, set.reps, set.weight)} className="bg-green-500 hover:bg-green-600 text-white p-2 rounded-full" title="Log Set"><CheckCircle size={20} /></button>)}{set.completed && (<button onClick={() => onUnlogSet(exIndex, setIndex)} className="bg-yellow-500 hover:bg-yellow-600 text-white p-2 rounded-full" title="Unlog Set"><RotateCcw size={20} /></button>)}</div>))}{!exercise.isSkipped && (<button onClick={() => onAddSetToExercise(exIndex)} className="w-full text-sm text-blue-400 hover:text-blue-300 border border-blue-500 hover:border-blue-400 rounded-lg py-1.5 px-3 mt-1 flex items-center justify-center transition-colors"><PlusCircle size={16} className="mr-1"/> Add Set</button>)}</div>))}{activeWorkout.exercises.length === 0 && <p className="text-sm text-gray-400 text-center py-2">No exercises in this workout.</p>}<div className="my-6 bg-gray-800 p-4 rounded-lg"><label htmlFor="workoutNotes" className="block text-sm font-medium text-gray-300 mb-1">Workout Notes</label><textarea id="workoutNotes" value={workoutNotes} onChange={(e) => onSetWorkoutNotes(e.target.value)} rows="3" className="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-2 focus:ring-pink-500 focus:border-pink-500" placeholder="How did it go? Any PRs?"></textarea></div><button onClick={onFinishWorkout} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg flex items-center justify-center transition-colors"><CheckCircle size={22} className="mr-2"/> Finish & Save Workout</button></div> );});
const WorkoutHistoryScreen = React.memo(({ workoutLogs, onEditWorkoutPlanFromLog, onDeleteWorkoutLog }) => ( /* ... as before ... */ <div className="p-4 md:p-6"><h1 className="text-3xl font-bold mb-6 text-center text-pink-500">Workout History</h1>{workoutLogs.length === 0 && <p className="text-gray-400 text-center">No completed workouts yet. Go crush one!</p>}<div className="space-y-4">{workoutLogs.map(log => (<div key={log.id} className="bg-gray-800 p-4 rounded-lg shadow-md"><div className="flex justify-between items-start mb-2"><div><h2 className="text-xl font-semibold text-pink-400">{log.name}</h2><p className="text-sm text-gray-400">{log.startTime?.toDate ? new Date(log.startTime.toDate()).toLocaleDateString() : 'Date N/A'}{log.startTime?.toDate && log.endTime?.toDate && ` (${Math.round((log.endTime.toDate().getTime() - log.startTime.toDate().getTime()) / 60000)} min)`}</p></div><div className="flex flex-col sm:flex-row items-end sm:items-center space-y-1 sm:space-y-0 sm:space-x-2">{log.bodyWeight && <p className="text-xs text-gray-300 bg-gray-700 px-2 py-0.5 rounded">Body Wt: {log.bodyWeight} lbs</p>}<div className="flex space-x-1">{log.templateId && <button onClick={() => onEditWorkoutPlanFromLog(log.templateId)} className="p-1 text-blue-400 hover:text-blue-300" title="Edit Original Plan"><Edit size={16}/></button>}<button onClick={() => onDeleteWorkoutLog(log.id)} className="p-1 text-red-400 hover:text-red-300" title="Delete This Log"><Trash2 size={16}/></button></div></div></div>{(log.exercises || []).map((ex, idx) => (<details key={idx} className="mb-1 last:mb-0 group"><summary className="text-md text-gray-300 cursor-pointer hover:text-pink-300 py-1 flex items-center"><ChevronDown size={16} className="mr-2 group-open:hidden" /><ChevronUp size={16} className="mr-2 hidden group-open:inline" />{ex.name} {ex.isSkipped ? <span className="ml-2 text-xs bg-yellow-600 px-1.5 py-0.5 rounded">Skipped</span> : ''}</summary><div className="pl-6 pt-1 pb-2 text-xs text-gray-400 border-l border-gray-700 ml-2">{ex.loggedSets.map((s, sIdx) => (<div key={sIdx}>Set {sIdx + 1}: {s.reps} reps @ {s.weight} lbs</div>))}{ex.loggedSets.length === 0 && !ex.isSkipped && <div>No sets logged for this exercise.</div>}</div></details>))}{log.notes && <p className="mt-2 text-sm text-gray-300 italic border-t border-gray-700 pt-2">Notes: {log.notes}</p>}</div>))}</div></div>));
const TimerDisplay = React.memo(({ timerActive, timerSeconds, timerPaused, onResumeTimer, onPauseTimer, onStopTimer, formatTime}) => { /* ... as before ... */ if (!timerActive) return null; return ( <div className="fixed bottom-0 left-0 right-0 bg-gray-800 p-4 border-t-2 border-pink-500 shadow-2xl z-50"><div className="container mx-auto flex flex-col sm:flex-row justify-between items-center"><div className="text-center sm:text-left mb-2 sm:mb-0"><p className="text-sm text-gray-400">Rest Timer</p><p className="text-4xl font-bold text-pink-400">{formatTime(timerSeconds)}</p></div><div className="flex space-x-2">{timerPaused ? (<button onClick={onResumeTimer} className="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg flex items-center"><Play size={18} className="mr-1"/> Resume</button>) : (<button onClick={onPauseTimer} className="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg flex items-center"><Pause size={18} className="mr-1"/> Pause</button>)}<button onClick={onStopTimer} className="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg flex items-center"><StopCircle size={18} className="mr-1"/> Stop</button></div></div></div> );});

// --- Main App Component ---
function App() {
    // ... (Firebase State, App State, Timer State, Body Weight State, Notes State - all as before) ...
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [user, setUser] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [workouts, setWorkouts] = useState([]);
    const [activeWorkout, setActiveWorkout] = useState(null);
    const [currentScreen, setCurrentScreen] = useState('home');
    const [editingWorkout, setEditingWorkout] = useState(null);
    const [workoutLogs, setWorkoutLogs] = useState([]);
    const [infoModalMessage, setInfoModalMessage] = useState('');
    const [isInfoModalOpen, setIsInfoModalOpen] = useState(false);
    const [confirmModalMessage, setConfirmModalMessage] = useState('');
    const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
    const [itemToDelete, setItemToDelete] = useState(null);
    const [replacingExerciseIndex, setReplacingExerciseIndex] = useState(null);
    const [tempReplaceName, setTempReplaceName] = useState('');
    const [timerActive, setTimerActive] = useState(false);
    const [timerPaused, setTimerPaused] = useState(false);
    const [timerSeconds, setTimerSeconds] = useState(180);
    const timerIntervalRef = useRef(null);
    const [bodyWeight, setBodyWeight] = useState('');
    const [showBodyWeightInput, setShowBodyWeightInput] = useState(false);
    const [workoutNotes, setWorkoutNotes] = useState('');
    const draggedItemIndex = useRef(null);
    // const draggedOverItemIndex = useRef(null); // Not currently used, can be removed if not needed for advanced styling


    // --- Firebase Initialization and Auth Listener ---
    useEffect(() => { /* ... as before ... */ try { const app = initializeApp(firebaseConfig); const firestoreDb = getFirestore(app); const firebaseAuth = getAuth(app); setDb(firestoreDb); setAuth(firebaseAuth); const unsubscribe = onAuthStateChanged(firebaseAuth, (currentUser) => { setUser(currentUser); setIsAuthReady(true); if (!currentUser) { setCurrentScreen('home'); setWorkouts([]); setWorkoutLogs([]); setActiveWorkout(null); setEditingWorkout(null); } }); return () => unsubscribe(); } catch (error) { console.error("Error initializing Firebase:", error); setIsAuthReady(true); } }, []);
    const userId = user ? user.uid : null;

    // --- Google Sign-In/Out Handlers ---
    const handleSignInWithGoogle = useCallback(async () => { /* ... as before ... */ if (!auth) { console.error("Firebase Auth not initialized for Google Sign-In"); return; } const provider = new GoogleAuthProvider(); try { await signInWithPopup(auth, provider); setCurrentScreen('home'); } catch (error) { console.error("Error signing in with Google:", error); } }, [auth]);
    const handleSignOut = useCallback(async () => { /* ... as before ... */ if (!auth) { console.error("Firebase Auth not initialized for Sign Out"); return; } try { await signOut(auth); } catch (error) { console.error("Error signing out:", error); } }, [auth]);

    // --- Data Fetching ---
    useEffect(() => { 
        if (!db || !userId || !isAuthReady) { 
            if (isAuthReady && !userId) setWorkouts([]); 
            return; 
        } 
        const workoutsCollectionPath = `artifacts/${appId}/users/${userId}/workouts`; 
        const q = query(collection(db, workoutsCollectionPath)); 
        const unsubscribe = onSnapshot(q, (querySnapshot) => { 
            const fetchedWorkouts = []; 
            querySnapshot.forEach((doc) => { 
                fetchedWorkouts.push({ id: doc.id, ...doc.data() }); 
            }); 
            setWorkouts(fetchedWorkouts.sort((a, b) => (a.order || 0) - (b.order || 0) || (a.name || "").localeCompare(b.name || ""))); 
        }, (error) => console.error("Error fetching workouts:", error)); 
        return () => unsubscribe(); 
    }, [db, userId, isAuthReady]);

    useEffect(() => { /* ... workoutLogs fetch, as before ... */ if (!db || !userId || !isAuthReady) { if (isAuthReady && !userId) setWorkoutLogs([]); return; } const logsCollectionPath = `artifacts/${appId}/users/${userId}/workoutLogs`; const q = query(collection(db, logsCollectionPath)); const unsubscribe = onSnapshot(q, (querySnapshot) => { const fetchedLogs = []; querySnapshot.forEach((doc) => { fetchedLogs.push({ id: doc.id, ...doc.data() }); }); setWorkoutLogs(fetchedLogs.sort((a, b) => (b.startTime?.toDate?.() || 0) - (a.startTime?.toDate?.() || 0))); }, (error) => console.error("Error fetching workout logs:", error)); return () => unsubscribe(); }, [db, userId, isAuthReady]);

    // --- Timer Logic ---
    useEffect(() => { /* ... as before ... */ if (timerActive && !timerPaused) { timerIntervalRef.current = setInterval(() => { setTimerSeconds(prev => { if (prev <= 1) { clearInterval(timerIntervalRef.current); setTimerActive(false); return 0; } return prev - 1; }); }, 1000); } else { clearInterval(timerIntervalRef.current); } return () => clearInterval(timerIntervalRef.current); }, [timerActive, timerPaused]);
    const startTimer = useCallback((duration = 180) => { setTimerSeconds(duration); setTimerActive(true); setTimerPaused(false); }, []);
    const pauseTimer = useCallback(() => setTimerPaused(true), []);
    const resumeTimer = useCallback(() => setTimerPaused(false), []);
    const stopTimer = useCallback(() => { setTimerActive(false); setTimerPaused(false); setTimerSeconds(180); }, []);
    const formatTime = useCallback((totalSeconds) => { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; }, []);

    // --- Info/Error Modal ---
    const showInfoModal = useCallback((message) => { setInfoModalMessage(String(message)); setIsInfoModalOpen(true); }, []); 

    // --- Workout Template Management Callbacks ---
    const handleCreateNewWorkout = useCallback(() => { 
        const newOrder = workouts.length > 0 ? Math.max(...workouts.map(w => w.order || 0)) + 1 : 0;
        setEditingWorkout({ 
            id: null, 
            name: '', 
            order: newOrder,
            exercises: [{ id: generateId(), name: '', targetSets: 3, targetRepsMin: 8, targetRepsMax: 12, targetWeight: '' }] 
        }); 
        setCurrentScreen('createWorkout'); 
    }, [workouts]);
    const handleEditWorkoutTemplate = useCallback((workout) => { setEditingWorkout(JSON.parse(JSON.stringify(workout))); setCurrentScreen('createWorkout'); }, []);
    const handleSaveWorkoutTemplate = useCallback(async () => { if (!editingWorkout) { showInfoModal("No workout data to save."); return; } if (!editingWorkout.name.trim()) { showInfoModal("Workout Plan Name is required."); return; } const emptyExercise = editingWorkout.exercises.find(ex => !ex.name.trim()); if (emptyExercise) { showInfoModal(`All exercises must have a name. Exercise #${editingWorkout.exercises.indexOf(emptyExercise) + 1} is missing a name.`); return; } if (!db || !userId) { showInfoModal("Cannot save: Database connection or User ID is missing."); return; } const workoutToSave = { ...editingWorkout, exercises: editingWorkout.exercises.filter(ex => ex.name.trim() !== '') }; if(typeof workoutToSave.order === 'undefined') { workoutToSave.order = workouts.length > 0 ? Math.max(...workouts.map(w => w.order || 0)) + 1 : 0; } try { const workoutsCollectionPath = `artifacts/${appId}/users/${userId}/workouts`; if (workoutToSave.id) { await setDoc(doc(db, workoutsCollectionPath, workoutToSave.id), workoutToSave, { merge: true }); } else { const { id, ...dataForNewWorkout } = workoutToSave; await addDoc(collection(db, workoutsCollectionPath), dataForNewWorkout); } setEditingWorkout(null); setCurrentScreen('home'); } catch (error) { console.error("Error saving workout template:", error); showInfoModal("Error saving workout: " + ( String(error.message) || "Unknown error")); } }, [db, userId, editingWorkout, showInfoModal, workouts]);
    const requestDeleteWorkoutTemplate = useCallback((workoutId) => { setItemToDelete({ id: workoutId, type: 'template' }); setConfirmModalMessage("Are you sure you want to delete this workout plan? This action cannot be undone."); setIsConfirmModalOpen(true); }, []);
    const handleWorkoutNameChange = useCallback((newName) => { setEditingWorkout(prev => ({ ...prev, name: newName })); }, []);
    const handleExerciseChange = useCallback((exerciseIndex, field, value) => { setEditingWorkout(prev => ({ ...prev, exercises: prev.exercises.map((ex, i) => i === exerciseIndex ? { ...ex, [field]: value } : ex) })); }, []);
    const addExerciseToTemplate = useCallback(() => { setEditingWorkout(prev => ({ ...prev, exercises: [...prev.exercises, { id: generateId(), name: '', targetSets: 3, targetRepsMin: 8, targetRepsMax: 12, targetWeight: '' }] })); }, []);
    const removeExerciseFromTemplate = useCallback((exerciseId) => { setEditingWorkout(prev => ({ ...prev, exercises: prev.exercises.filter(ex => ex.id !== exerciseId) })); }, []);

    // --- Drag and Drop for Workout Plans (HomeScreen) ---
    const handleWorkoutPlanDragStart = useCallback((e, index) => {
        draggedItemIndex.current = index;
        e.dataTransfer.effectAllowed = 'move';
        if (e.currentTarget) {
            e.currentTarget.classList.add('opacity-50', 'border-pink-500', 'border-2');
        }
    }, []);

    const handleWorkoutPlanDragOver = useCallback((e) => {
        e.preventDefault(); 
        e.dataTransfer.dropEffect = 'move';
    }, []);
    
    const handleWorkoutPlanDrop = useCallback(async (e, index) => {
        e.preventDefault();
        const draggedIndex = draggedItemIndex.current;
        const targetIndex = index;
        // draggedItemIndex.current is reset in onDragEnd

        if (draggedIndex === null || draggedIndex === targetIndex) {
            return; // No change if dropped on itself or drag was invalid
        }

        const reorderedWorkouts = [...workouts];
        const [draggedItem] = reorderedWorkouts.splice(draggedIndex, 1);
        reorderedWorkouts.splice(targetIndex, 0, draggedItem);

        setWorkouts(reorderedWorkouts); // Optimistic UI update

        if (db && userId) {
            const batch = writeBatch(db);
            const collectionRef = collection(db, `artifacts/${appId}/users/${userId}/workouts`);
            reorderedWorkouts.forEach((workout, newOrderIndex) => {
                if (workout.id) {
                    const docRef = doc(collectionRef, workout.id);
                    batch.update(docRef, { order: newOrderIndex });
                }
            });
            try {
                await batch.commit();
                console.log("Workout plan order updated in Firestore.");
            } catch (error) {
                console.error("Error updating workout plan order:", error);
                showInfoModal("Failed to save new order. Please try again.");
                // Consider reverting optimistic update or re-fetching data on error
            }
        }
    }, [workouts, db, userId, showInfoModal, appId]);

    const handleWorkoutPlanDragEnd = useCallback((e) => {
        if (e.currentTarget) {
            e.currentTarget.classList.remove('opacity-50', 'border-pink-500', 'border-2');
        }
        // Also ensure any other items that might have had hover effects (if implemented) are cleaned.
        // For this simple case, only the dragged item is styled.
        draggedItemIndex.current = null; // Reset here
    }, []);


    // --- Drag and Drop for Exercises (CreateEditWorkoutScreen) ---
    const handleExerciseDragStart = useCallback((e, index) => { /* ... as before ... */ draggedItemIndex.current = index; e.dataTransfer.effectAllowed = 'move'; e.currentTarget.classList.add('opacity-50', 'ring-2', 'ring-pink-500'); }, []);
    const handleExerciseDragOver = useCallback((e) => { /* ... as before ... */ e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }, []);
    const handleExerciseDrop = useCallback((e, index) => { /* ... as before ... */ e.preventDefault(); const draggedIndex = draggedItemIndex.current; const targetIndex = index; draggedItemIndex.current = null; e.currentTarget.classList.remove('opacity-50', 'ring-2', 'ring-pink-500'); if (draggedIndex === null || draggedIndex === targetIndex) return; setEditingWorkout(prev => { if (!prev) return prev; const reorderedExercises = [...prev.exercises]; const [draggedItem] = reorderedExercises.splice(draggedIndex, 1); reorderedExercises.splice(targetIndex, 0, draggedItem); return { ...prev, exercises: reorderedExercises }; }); }, []);
    const handleExerciseDragEnd = useCallback((e) => { /* ... as before ... */ e.currentTarget.classList.remove('opacity-50', 'ring-2', 'ring-pink-500'); draggedItemIndex.current = null; }, []);

    // --- Active Workout Management Callbacks ---
    const handleStartWorkout = useCallback((workoutTemplate) => { /* ... as in previous version with formatPreviousPerformanceString ... */  let previousPerformanceData = {}; if (workoutLogs && workoutLogs.length > 0) { const relevantLogs = workoutLogs.filter(log => log.templateId === workoutTemplate.id && log.isCompleted).sort((a, b) => (b.startTime?.toDate?.() || 0) - (a.startTime?.toDate?.() || 0)); if (relevantLogs.length > 0) { const lastLog = relevantLogs[0]; (lastLog.exercises || []).forEach(prevEx => { const performanceString = formatPreviousPerformanceString(prevEx.loggedSets); if (performanceString) { previousPerformanceData[prevEx.name] = performanceString; } }); } } setActiveWorkout({ templateId: workoutTemplate.id, name: workoutTemplate.name, startTime: serverTimestamp(), bodyWeight: '', notes: '', exercises: workoutTemplate.exercises.map(ex => ({ ...ex, id: ex.id || generateId(), loggedSets: Array(parseInt(ex.targetSets, 10) || 1).fill(null).map(() => ({ reps: '', weight: '', completed: false })), isSkipped: false, previousPerformance: previousPerformanceData[ex.name] || null })), isCompleted: false }); setWorkoutNotes(''); setBodyWeight(''); setShowBodyWeightInput(true); setCurrentScreen('activeWorkout'); setReplacingExerciseIndex(null); }, [workoutLogs]);
    const handleUnlogSet = useCallback((exerciseIndex, setIndex) => { setActiveWorkout(prevWorkout => { const newExercises = prevWorkout.exercises.map((exercise, exIdx) => { if (exIdx === exerciseIndex) { const newLoggedSets = exercise.loggedSets.map((set, sIdx) => { if (sIdx === setIndex) { return { ...set, reps: '', weight: '', completed: false }; } return set; }); return { ...exercise, loggedSets: newLoggedSets }; } return exercise; }); return { ...prevWorkout, exercises: newExercises }; }); }, []);
    const handleToggleSkipExercise = useCallback((exerciseIndex) => { setActiveWorkout(prevWorkout => { const newExercises = prevWorkout.exercises.map((ex, idx) => { if (idx === exerciseIndex) { return { ...ex, isSkipped: !ex.isSkipped }; } return ex; }); return { ...prevWorkout, exercises: newExercises }; }); }, []);
    const handleStartReplaceExercise = useCallback((exerciseIndex, currentName) => { setReplacingExerciseIndex(exerciseIndex); setTempReplaceName(currentName); }, []);
    const handleConfirmReplaceExercise = useCallback((exerciseIndex) => { if (!tempReplaceName.trim()) { showInfoModal("New exercise name cannot be empty."); return; } setActiveWorkout(prevWorkout => { const newExercises = prevWorkout.exercises.map((ex, idx) => { if (idx === exerciseIndex) { return { ...ex, name: tempReplaceName }; } return ex; }); return { ...prevWorkout, exercises: newExercises }; }); setReplacingExerciseIndex(null); setTempReplaceName(''); }, [tempReplaceName, showInfoModal]);
    const handleCancelReplaceExercise = useCallback(() => { setReplacingExerciseIndex(null); setTempReplaceName(''); }, []);
    const handleLogSet = useCallback((exerciseIndex, setIndex, reps, weight) => { setActiveWorkout(prev => { const updatedWorkout = { ...prev }; updatedWorkout.exercises[exerciseIndex].loggedSets[setIndex] = { reps, weight, completed: true }; return updatedWorkout; }); startTimer(); }, [startTimer]);
    const handleAddSetToExercise = useCallback((exerciseIndex) => { setActiveWorkout(prevWorkout => { const newExercises = prevWorkout.exercises.map((exercise, exIdx) => { if (exIdx === exerciseIndex) { const newLoggedSets = [...exercise.loggedSets, { reps: '', weight: '', completed: false }]; return { ...exercise, loggedSets: newLoggedSets }; } return exercise; }); return { ...prevWorkout, exercises: newExercises }; }); }, []);
    const handleSetInputChange = useCallback((exerciseIndex, setIndex, field, value) => { setActiveWorkout(prevWorkout => { const newExercises = prevWorkout.exercises.map((exercise, exIdx) => { if (exIdx === exerciseIndex) { const newLoggedSets = exercise.loggedSets.map((set, sIdx) => sIdx === setIndex ? { ...set, [field]: value } : set); return { ...exercise, loggedSets: newLoggedSets }; } return exercise; }); return { ...prevWorkout, exercises: newExercises }; }); }, []);
    const handleFinishWorkout = useCallback(async () => { if (!db || !userId || !activeWorkout) return; const finalBodyWeight = bodyWeight || activeWorkout.bodyWeight || ''; const finalNotes = workoutNotes || activeWorkout.notes || ''; const workoutLog = { ...activeWorkout, bodyWeight: finalBodyWeight, notes: finalNotes, endTime: serverTimestamp(), isCompleted: true, exercises: activeWorkout.exercises.map(ex => ({ ...ex, loggedSets: ex.loggedSets.filter(s => s.completed || ex.isSkipped) })) }; try { await addDoc(collection(db, `artifacts/${appId}/users/${userId}/workoutLogs`), workoutLog); setActiveWorkout(null); setCurrentScreen('home'); stopTimer(); setBodyWeight(''); setWorkoutNotes(''); setShowBodyWeightInput(false); } catch (error) { console.error("Error finishing workout:", error); showInfoModal("Error saving workout log: " + (String(error.message) || "Unknown error")); } }, [db, userId, activeWorkout, bodyWeight, workoutNotes, stopTimer, showInfoModal]);
    const handleCancelActiveWorkout = useCallback(() => { setActiveWorkout(null); setCurrentScreen('home'); stopTimer(); setReplacingExerciseIndex(null); setTempReplaceName(''); }, [stopTimer]);
    const handleCancelCreateEdit = useCallback(() => { setEditingWorkout(null); setCurrentScreen('home'); }, []);

    // --- Workout History Enhancements ---
    const handleEditWorkoutPlanFromLog = useCallback(async (templateId) => { if (!db || !userId || !templateId) { showInfoModal("Cannot find original plan: Missing template information from log."); return; } try { const templateDocRef = doc(db, `artifacts/${appId}/users/${userId}/workouts`, templateId); const templateSnap = await getDoc(templateDocRef); if (templateSnap.exists()) { handleEditWorkoutTemplate({ id: templateSnap.id, ...templateSnap.data() }); } else { showInfoModal("Original workout plan not found. It may have been deleted."); } } catch (error) { console.error("Error fetching workout plan for editing:", error); showInfoModal("Error fetching plan: " + (String(error.message) || "Unknown error")); } }, [db, userId, handleEditWorkoutTemplate, showInfoModal]); 
    const requestDeleteWorkoutLog = useCallback((logId) => { setItemToDelete({ id: logId, type: 'log' }); setConfirmModalMessage("Are you sure you want to delete this workout log? This action cannot be undone."); setIsConfirmModalOpen(true); }, []);

    // --- Confirm Delete Handler ---
    const handleConfirmDelete = useCallback(async () => { if (!db || !userId || !itemToDelete) { showInfoModal("Cannot delete: Missing required information."); setIsConfirmModalOpen(false); setItemToDelete(null); return; } const { id, type } = itemToDelete; let collectionPath = ''; let successMessage = ''; let errorMessagePrefix = ''; if (type === 'template') { collectionPath = `artifacts/${appId}/users/${userId}/workouts`; successMessage = "Workout plan deleted successfully."; errorMessagePrefix = "Error deleting template: "; } else if (type === 'log') { collectionPath = `artifacts/${appId}/users/${userId}/workoutLogs`; successMessage = "Workout log deleted successfully."; errorMessagePrefix = "Error deleting log: "; } else { showInfoModal("Invalid item type for deletion."); setIsConfirmModalOpen(false); setItemToDelete(null); return; } try { await deleteDoc(doc(db, collectionPath, id)); console.log(successMessage); } catch (error) { console.error(`Raw error object during delete ${type}:`, error); let detailMessage = "An unknown error occurred."; if (error) { if (typeof error.message === 'string' && error.message.trim() !== '') { detailMessage = error.message; } else if (typeof error === 'string' && error.trim() !== '') { detailMessage = error; } else { try { const errStr = JSON.stringify(error); if (errStr !== '{}') detailMessage = errStr; } catch (e) { /* ignore */ } } } showInfoModal(errorMessagePrefix + detailMessage); } finally { setIsConfirmModalOpen(false); setItemToDelete(null); } }, [db, userId, itemToDelete, showInfoModal]);

    // --- UI Rendering ---
    const renderAppContent = () => { switch (currentScreen) { case 'home': return <HomeScreen workouts={workouts} onStartWorkout={handleStartWorkout} onEditWorkoutTemplate={handleEditWorkoutTemplate} onDeleteWorkoutTemplate={requestDeleteWorkoutTemplate} onCreateNewWorkout={handleCreateNewWorkout} onWorkoutPlanDragStart={handleWorkoutPlanDragStart} onWorkoutPlanDragOver={handleWorkoutPlanDragOver} onWorkoutPlanDrop={handleWorkoutPlanDrop} onWorkoutPlanDragEnd={handleWorkoutPlanDragEnd} />; case 'createWorkout': return <CreateEditWorkoutScreen editingWorkout={editingWorkout} onWorkoutNameChange={handleWorkoutNameChange} onExerciseChange={handleExerciseChange} onAddExerciseToTemplate={addExerciseToTemplate} onRemoveExerciseFromTemplate={removeExerciseFromTemplate} onSaveWorkoutTemplate={handleSaveWorkoutTemplate} onCancel={handleCancelCreateEdit} onExerciseDragStart={handleExerciseDragStart} onExerciseDragOver={handleExerciseDragOver} onExerciseDrop={handleExerciseDrop} onExerciseDragEnd={handleExerciseDragEnd} />; case 'activeWorkout': return <ActiveWorkoutScreen activeWorkout={activeWorkout} bodyWeight={bodyWeight} workoutNotes={workoutNotes} onSetBodyWeight={setBodyWeight} onSetWorkoutNotes={setWorkoutNotes} onSetInputChange={handleSetInputChange} onAddSetToExercise={handleAddSetToExercise} onLogSet={handleLogSet} onUnlogSet={handleUnlogSet} onFinishWorkout={handleFinishWorkout} onCancelWorkout={handleCancelActiveWorkout} showBodyWeightInput={showBodyWeightInput} onHideBodyWeightInput={() => setShowBodyWeightInput(false)} onToggleSkipExercise={handleToggleSkipExercise} onStartReplaceExercise={handleStartReplaceExercise} replacingExerciseIndex={replacingExerciseIndex} onConfirmReplaceExercise={handleConfirmReplaceExercise} onCancelReplaceExercise={handleCancelReplaceExercise} tempReplaceName={tempReplaceName} onSetTempReplaceName={setTempReplaceName} />; case 'workoutHistory': return <WorkoutHistoryScreen workoutLogs={workoutLogs} onEditWorkoutPlanFromLog={handleEditWorkoutPlanFromLog} onDeleteWorkoutLog={requestDeleteWorkoutLog} />; default: setCurrentScreen('home'); return <HomeScreen workouts={workouts} onStartWorkout={handleStartWorkout} onEditWorkoutTemplate={handleEditWorkoutTemplate} onDeleteWorkoutTemplate={requestDeleteWorkoutTemplate} onCreateNewWorkout={handleCreateNewWorkout} onWorkoutPlanDragStart={handleWorkoutPlanDragStart} onWorkoutPlanDragOver={handleWorkoutPlanDragOver} onWorkoutPlanDrop={handleWorkoutPlanDrop} onWorkoutPlanDragEnd={handleWorkoutPlanDragEnd} />; } };
    if (!isAuthReady) { return <div className="flex justify-center items-center h-screen bg-gray-900 text-white"><Clock className="animate-spin mr-2" />Authenticating...</div>; }
    if (!user) { return <LoginScreen onSignInWithGoogle={handleSignInWithGoogle} />; }
    return ( <> <Modal isOpen={isInfoModalOpen} onClose={() => setIsInfoModalOpen(false)} title="Information" confirmText="OK" > <div className="flex items-center"> <MessageSquareWarning size={48} className="text-yellow-400 mr-4 flex-shrink-0" /> <p className="text-gray-300">{infoModalMessage}</p> </div> </Modal> <Modal isOpen={isConfirmModalOpen} onClose={() => { setIsConfirmModalOpen(false); setItemToDelete(null); }} title="Confirm Deletion" showCancelButton={true} onConfirm={handleConfirmDelete} confirmText="Delete" cancelText="Cancel" > <div className="flex items-center"> <AlertTriangle size={48} className="text-red-500 mr-4 flex-shrink-0" /> <p className="text-gray-300">{confirmModalMessage}</p> </div> </Modal> <div className="min-h-screen bg-gray-900 text-white font-sans flex flex-col"> <header className="bg-gray-800 shadow-md sticky top-0 z-40"> <div className="container mx-auto px-4 py-3 flex justify-between items-center"><div className="text-2xl font-bold text-pink-500 flex items-center"><Dumbbell size={28} className="mr-2"/> FitTrack</div><div className="flex items-center">{user.photoURL && <img src={user.photoURL} alt="User" className="w-8 h-8 rounded-full mr-3"/>}<span className="text-sm text-gray-300 mr-4 hidden sm:inline">{user.displayName || user.email}</span><button onClick={handleSignOut} className="bg-pink-600 hover:bg-pink-700 text-white font-semibold py-1.5 px-3 rounded-lg text-sm flex items-center"><LogOut size={16} className="mr-1.5"/> Sign Out</button></div></div> </header> <main className="flex-grow container mx-auto px-0 sm:px-4 py-4"> {renderAppContent()} </main> <TimerDisplay timerActive={timerActive} timerSeconds={timerSeconds} timerPaused={timerPaused} onResumeTimer={resumeTimer} onPauseTimer={pauseTimer} onStopTimer={stopTimer} formatTime={formatTime} /> <footer className="bg-gray-800 border-t border-gray-700 p-3 sticky bottom-0 z-30 mt-auto"> <nav className="container mx-auto flex justify-around items-center"><button onClick={() => setCurrentScreen('home')} className={`flex flex-col items-center p-2 rounded-md ${currentScreen === 'home' ? 'text-pink-400' : 'text-gray-400 hover:text-pink-300'}`}><Home size={22}/> <span className="text-xs mt-1">Home</span></button><button onClick={() => setCurrentScreen('workoutHistory')} className={`flex flex-col items-center p-2 rounded-md ${currentScreen === 'workoutHistory' ? 'text-pink-400' : 'text-gray-400 hover:text-pink-300'}`}><Calendar size={22}/> <span className="text-xs mt-1">History</span></button></nav> </footer> </div> </> );
}

export default App;
